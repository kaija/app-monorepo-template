name: Database CI

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/alembic/**'
      - 'backend/app/models/**'
      - '.github/workflows/database-ci.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'backend/alembic/**'
      - 'backend/app/models/**'
      - '.github/workflows/database-ci.yml'
  workflow_call:

jobs:
  migration-validation:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    defaults:
      run:
        working-directory: ./backend
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        cache: 'pip'
        cache-dependency-path: backend/requirements.txt
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -e .
    
    - name: Validate migration files
      run: |
        # Check if migration files are properly formatted
        python -c "
        import os
        import re
        
        migration_dir = 'alembic/versions'
        if os.path.exists(migration_dir):
            for file in os.listdir(migration_dir):
                if file.endswith('.py') and file != '__init__.py':
                    with open(os.path.join(migration_dir, file), 'r') as f:
                        content = f.read()
                        # Check for required Alembic functions (with or without type annotations)
                        if not re.search(r'def upgrade\(\).*:', content):
                            raise ValueError(f'Migration {file} missing upgrade() function')
                        if not re.search(r'def downgrade\(\).*:', content):
                            raise ValueError(f'Migration {file} missing downgrade() function')
                    print(f'✓ Migration {file} is valid')
        "
    
    - name: Test fresh database migration
      env:
        DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/testdb
      run: |
        # Test migrating from scratch
        alembic upgrade head
        echo "✓ Fresh migration successful"
    
    - name: Test migration rollback
      env:
        DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/testdb
      run: |
        # Test rolling back one migration
        alembic downgrade -1
        echo "✓ Migration rollback successful"
        
        # Test migrating back up
        alembic upgrade head
        echo "✓ Migration re-apply successful"
    
    - name: Validate database schema
      env:
        DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/testdb
      run: |
        # Run schema validation script
        python -c "
        from sqlalchemy import create_engine, inspect
        import os
        
        engine = create_engine(os.getenv('DATABASE_URL'))
        inspector = inspect(engine)
        
        # Check that expected tables exist
        tables = inspector.get_table_names()
        expected_tables = ['users', 'items', 'alembic_version']
        
        for table in expected_tables:
            if table not in tables:
                raise ValueError(f'Expected table {table} not found')
            print(f'✓ Table {table} exists')
        
        # Check users table structure
        users_columns = [col['name'] for col in inspector.get_columns('users')]
        expected_users_columns = ['id', 'email', 'password_hash', 'oauth_provider', 'oauth_id', 'display_name', 'avatar_url', 'is_active', 'created_at', 'updated_at']
        
        for col in expected_users_columns:
            if col not in users_columns:
                raise ValueError(f'Expected column {col} not found in users table')
            print(f'✓ Users table column {col} exists')
        
        # Check items table structure
        items_columns = [col['name'] for col in inspector.get_columns('items')]
        expected_items_columns = ['id', 'name', 'description', 'price', 'user_id', 'created_at', 'updated_at']
        
        for col in expected_items_columns:
            if col not in items_columns:
                raise ValueError(f'Expected column {col} not found in items table')
            print(f'✓ Items table column {col} exists')
        
        print('✓ Database schema validation successful')
        "

  migration-performance:
    runs-on: ubuntu-latest
    needs: migration-validation
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    defaults:
      run:
        working-directory: ./backend
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -e .
    
    - name: Create test data and measure migration performance
      env:
        DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/testdb
      run: |
        # Run migrations and measure time
        start_time=$(date +%s)
        alembic upgrade head
        end_time=$(date +%s)
        
        migration_time=$((end_time - start_time))
        echo "Migration completed in ${migration_time} seconds"
        
        # Fail if migration takes too long (more than 30 seconds for CI)
        if [ $migration_time -gt 30 ]; then
          echo "❌ Migration took too long: ${migration_time}s (max: 30s)"
          exit 1
        else
          echo "✓ Migration performance acceptable: ${migration_time}s"
        fi
    
    - name: Test concurrent migration safety
      env:
        DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/testdb
      run: |
        # Test that running migrations concurrently doesn't cause issues
        python -c "
        import asyncio
        import subprocess
        import sys
        
        async def run_migration():
            process = await asyncio.create_subprocess_exec(
                'alembic', 'upgrade', 'head',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            return process.returncode, stdout, stderr
        
        async def test_concurrent_migrations():
            # Run two migrations concurrently
            tasks = [run_migration(), run_migration()]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # At least one should succeed, others should handle gracefully
            success_count = sum(1 for result in results if isinstance(result, tuple) and result[0] == 0)
            
            if success_count == 0:
                print('❌ No migrations succeeded')
                sys.exit(1)
            else:
                print(f'✓ Concurrent migration safety test passed ({success_count}/2 succeeded)')
        
        asyncio.run(test_concurrent_migrations())
        "

  backup-restore-test:
    runs-on: ubuntu-latest
    needs: migration-validation
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    defaults:
      run:
        working-directory: ./backend
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -e .
    
    - name: Test database backup and restore
      env:
        DATABASE_URL: postgresql://testuser:testpassword@localhost:5432/testdb
      run: |
        # Run migrations
        alembic upgrade head
        
        # Create some test data
        python -c "
        from sqlalchemy import create_engine, text
        import os
        
        engine = create_engine(os.getenv('DATABASE_URL'))
        
        with engine.connect() as conn:
            # Insert test user
            conn.execute(text('''
                INSERT INTO users (id, email, display_name, is_active) 
                VALUES (uuid_generate_v4(), 'test@example.com', 'Test User', true)
            '''))
            
            # Insert test item
            conn.execute(text('''
                INSERT INTO items (id, name, description, price, user_id) 
                SELECT uuid_generate_v4(), 'Test Item', 'Test Description', 99.99, id 
                FROM users WHERE email = 'test@example.com'
            '''))
            
            conn.commit()
            print('✓ Test data created')
        "
        
        # Create backup
        pg_dump -h localhost -U testuser -d testdb > backup.sql
        echo "✓ Database backup created"
        
        # Drop and recreate database
        dropdb -h localhost -U testuser testdb
        createdb -h localhost -U testuser testdb
        echo "✓ Database recreated"
        
        # Restore from backup
        psql -h localhost -U testuser -d testdb < backup.sql
        echo "✓ Database restored from backup"
        
        # Verify data integrity
        python -c "
        from sqlalchemy import create_engine, text
        import os
        
        engine = create_engine(os.getenv('DATABASE_URL'))
        
        with engine.connect() as conn:
            # Check that test data exists
            result = conn.execute(text('SELECT COUNT(*) FROM users WHERE email = :email'), {'email': 'test@example.com'})
            user_count = result.scalar()
            
            if user_count != 1:
                raise ValueError(f'Expected 1 test user, found {user_count}')
            
            result = conn.execute(text('SELECT COUNT(*) FROM items WHERE name = :name'), {'name': 'Test Item'})
            item_count = result.scalar()
            
            if item_count != 1:
                raise ValueError(f'Expected 1 test item, found {item_count}')
            
            print('✓ Data integrity verified after restore')
        "