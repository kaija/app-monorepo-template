name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'prod'
        type: choice
        options:
        - prod
        - staging

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: line-commerce-backend

jobs:
  # Run all CI checks before deployment
  validate-deployment:
    runs-on: ubuntu-latest
    outputs:
      frontend-changed: ${{ steps.changes.outputs.frontend }}
      backend-changed: ${{ steps.changes.outputs.backend }}
      infra-changed: ${{ steps.changes.outputs.infra }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          frontend:
            - 'frontend/**'
          backend:
            - 'backend/**'
          infra:
            - 'infra/**'

    - name: Validate deployment readiness
      run: |
        echo "Frontend changed: ${{ steps.changes.outputs.frontend }}"
        echo "Backend changed: ${{ steps.changes.outputs.backend }}"
        echo "Infrastructure changed: ${{ steps.changes.outputs.infra }}"

  # Build and push backend Docker image
  build-backend:
    runs-on: ubuntu-latest
    needs: validate-deployment
    if: needs.validate-deployment.outputs.backend-changed == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push backend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build Docker image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest ./backend

        # Push images to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

        echo "Backend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # Deploy infrastructure changes
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [validate-deployment, build-backend]
    if: always() && (needs.validate-deployment.outputs.infra-changed == 'true' || needs.validate-deployment.outputs.backend-changed == 'true')

    defaults:
      run:
        working-directory: ./infra

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ~1.0
        terraform_wrapper: false

    - name: Terraform Init
      env:
        TF_VAR_backend_image_tag: ${{ github.sha }}
      run: |
        terraform init -backend-config=backend-prod.hcl

    - name: Terraform Plan
      env:
        TF_VAR_backend_image_tag: ${{ github.sha }}
      run: |
        terraform workspace select prod || terraform workspace new prod
        terraform plan -var-file=environments/prod.tfvars -out=terraform-prod.tfplan

    - name: Terraform Apply
      env:
        TF_VAR_backend_image_tag: ${{ github.sha }}
      run: |
        terraform apply terraform-prod.tfplan

    - name: Get infrastructure outputs
      id: terraform-outputs
      run: |
        echo "backend-url=$(terraform output -raw backend_api_url)" >> $GITHUB_OUTPUT
        echo "frontend-url=$(terraform output -raw frontend_url)" >> $GITHUB_OUTPUT

  # Deploy frontend to Vercel
  deploy-frontend:
    runs-on: ubuntu-latest
    needs: [validate-deployment, deploy-infrastructure]
    if: always() && needs.validate-deployment.outputs.frontend-changed == 'true'

    defaults:
      run:
        working-directory: ./frontend

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: npm ci

    - name: Build application
      env:
        NEXT_PUBLIC_API_URL: ${{ needs.deploy-infrastructure.outputs.backend-url || secrets.BACKEND_API_URL }}
      run: npm run build

    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v25
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        working-directory: ./frontend
        vercel-args: '--prod'

  # Update backend service
  update-backend-service:
    runs-on: ubuntu-latest
    needs: [build-backend, deploy-infrastructure]
    if: always() && needs.validate-deployment.outputs.backend-changed == 'true'

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update ECS service
      run: |
        # Force new deployment with updated image
        aws ecs update-service \
          --cluster line-commerce-prod-backend-cluster \
          --service line-commerce-prod-backend \
          --force-new-deployment

        echo "ECS service update initiated"

    - name: Wait for deployment to complete
      run: |
        # Wait for service to stabilize
        aws ecs wait services-stable \
          --cluster line-commerce-prod-backend-cluster \
          --services line-commerce-prod-backend

        echo "Backend deployment completed successfully"

  # Run database migrations
  run-migrations:
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, update-backend-service]
    if: always() && (needs.validate-deployment.outputs.backend-changed == 'true' || needs.validate-deployment.outputs.infra-changed == 'true')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'

    - name: Install dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -e .

    - name: Run database migrations
      env:
        DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
      run: |
        cd backend
        alembic upgrade head
        echo "Database migrations completed successfully"

  # Post-deployment validation
  validate-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-frontend, update-backend-service, run-migrations]
    if: always()

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get deployment URLs
      id: get-urls
      run: |
        # Get backend URL from ECS service
        BACKEND_URL=$(aws elbv2 describe-load-balancers \
          --names line-commerce-prod-backend \
          --query 'LoadBalancers[0].DNSName' \
          --output text)

        echo "backend-url=https://$BACKEND_URL" >> $GITHUB_OUTPUT
        echo "frontend-url=${{ secrets.FRONTEND_URL }}" >> $GITHUB_OUTPUT

    - name: Health check backend
      run: |
        BACKEND_URL="${{ steps.get-urls.outputs.backend-url }}"

        # Wait for backend to be ready
        for i in {1..30}; do
          if curl -f -s "$BACKEND_URL/healthz" > /dev/null; then
            echo "‚úì Backend health check passed"
            break
          fi

          if [ $i -eq 30 ]; then
            echo "‚ùå Backend health check failed after 30 attempts"
            exit 1
          fi

          echo "Waiting for backend to be ready... (attempt $i/30)"
          sleep 10
        done

    - name: Health check frontend
      run: |
        FRONTEND_URL="${{ steps.get-urls.outputs.frontend-url }}"

        if curl -f -s "$FRONTEND_URL" > /dev/null; then
          echo "‚úì Frontend health check passed"
        else
          echo "‚ùå Frontend health check failed"
          exit 1
        fi

    - name: Run smoke tests
      run: |
        BACKEND_URL="${{ steps.get-urls.outputs.backend-url }}"

        # Test API endpoints
        echo "Testing API endpoints..."

        # Test health endpoint
        curl -f "$BACKEND_URL/healthz" || exit 1
        echo "‚úì Health endpoint working"

        # Test API documentation
        curl -f "$BACKEND_URL/docs" || exit 1
        echo "‚úì API documentation accessible"

        echo "‚úì All smoke tests passed"

  # Notify deployment status
  notify-deployment:
    runs-on: ubuntu-latest
    needs: [validate-deployment]
    if: always()

    steps:
    - name: Notify deployment success
      if: needs.validate-deployment.result == 'success'
      run: |
        echo "üöÄ Production deployment completed successfully!"
        echo "Frontend: ${{ secrets.FRONTEND_URL }}"
        echo "Backend: Available via load balancer"

    - name: Notify deployment failure
      if: needs.validate-deployment.result == 'failure'
      run: |
        echo "‚ùå Production deployment failed!"
        echo "Please check the logs and fix any issues."
        exit 1
